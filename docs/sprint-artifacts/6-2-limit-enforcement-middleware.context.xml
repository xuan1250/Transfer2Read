<?xml version="1.0" encoding="UTF-8"?>
<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>6</epicId>
    <storyId>2</storyId>
    <title>Limit Enforcement Middleware</title>
    <status>drafted</status>
    <generatedAt>2025-12-25</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/6-2-limit-enforcement-middleware.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Developer</asA>
    <iWant>to block uploads or conversions if the user has exceeded their limit</iWant>
    <soThat>the business model is respected and tier limits are enforced fairly</soThat>
    <tasks>
      <task id="1">Create Tier Limits Configuration (AC: #6)
        <subtask id="1.1">Create `backend/app/core/limits.py` with `TIER_LIMITS` configuration</subtask>
        <subtask id="1.2">Define limits for FREE, PRO, PREMIUM tiers</subtask>
        <subtask id="1.3">Add helper functions: `get_file_size_limit(tier)`, `get_conversion_limit(tier)`</subtask>
        <subtask id="1.4">Ensure limits are environment-configurable if needed (optional)</subtask>
      </task>
      <task id="2">Create Limit Enforcement Dependency (AC: #1, #2, #3)
        <subtask id="2.1">Create `backend/app/middleware/limits.py` or add to `backend/app/core/deps.py`</subtask>
        <subtask id="2.2">Implement `check_file_size_limit(user, content_length)` function</subtask>
        <subtask id="2.3">Implement `check_conversion_limit(user)` function using `UsageTracker.get_usage()`</subtask>
        <subtask id="2.4">Create combined `check_tier_limits` FastAPI dependency</subtask>
        <subtask id="2.5">Return `HTTPException(403)` with `LimitExceededError` schema on failure</subtask>
        <subtask id="2.6">Add detailed logging for limit check decisions</subtask>
      </task>
      <task id="3">Create Error Response Schema (AC: #5)
        <subtask id="3.1">Create `backend/app/schemas/errors.py` if not exists</subtask>
        <subtask id="3.2">Define `LimitExceededError` Pydantic model</subtask>
        <subtask id="3.3">Include all required fields: detail, code, tier, upgrade_url, contextual info</subtask>
        <subtask id="3.4">Document error codes in schema docstring</subtask>
      </task>
      <task id="4">Implement Tier Bypass Logic (AC: #4)
        <subtask id="4.1">Check user tier from `user.user_metadata.tier` or `current_user.tier`</subtask>
        <subtask id="4.2">Return early (bypass) if tier is PRO or PREMIUM</subtask>
        <subtask id="4.3">Default to FREE tier if tier is None or unrecognized</subtask>
        <subtask id="4.4">Log tier-based bypass decisions for monitoring</subtask>
      </task>
      <task id="5">Integrate with Upload Endpoint (AC: #7)
        <subtask id="5.1">Import `check_tier_limits` in `backend/app/api/v1/upload.py`</subtask>
        <subtask id="5.2">Add dependency to `POST /api/v1/upload` function signature</subtask>
        <subtask id="5.3">Ensure check runs BEFORE file processing (correct dependency order)</subtask>
        <subtask id="5.4">Test endpoint behavior with dependency injected</subtask>
        <subtask id="5.5">Update OpenAPI documentation with 403 response schema</subtask>
      </task>
      <task id="6">Unit Testing (AC: #8)
        <subtask id="6.1">Create `backend/tests/unit/middleware/test_limits.py`</subtask>
        <subtask id="6.2">Test `check_file_size_limit()` with various sizes and tiers</subtask>
        <subtask id="6.3">Test `check_conversion_limit()` with various counts and tiers</subtask>
        <subtask id="6.4">Test tier bypass logic (PRO, PREMIUM skip all checks)</subtask>
        <subtask id="6.5">Test edge cases (at limit, over limit, exactly 50MB)</subtask>
        <subtask id="6.6">Test default to FREE when tier is missing</subtask>
      </task>
      <task id="7">Integration Testing (AC: #8)
        <subtask id="7.1">Create `backend/tests/integration/test_api_limits.py`</subtask>
        <subtask id="7.2">Test FREE user at conversion limit → 403 with correct error schema</subtask>
        <subtask id="7.3">Test FREE user under limit → 200/202 (upload proceeds)</subtask>
        <subtask id="7.4">Test PRO user over "limit" → 200/202 (bypass works)</subtask>
        <subtask id="7.5">Test file size rejection → 403 with `FILE_SIZE_LIMIT_EXCEEDED`</subtask>
        <subtask id="7.6">Test error response body matches `LimitExceededError` schema</subtask>
        <subtask id="7.7">Manual test: Upload as FREE user → hit limit → verify 403 response</subtask>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1" title="Backend Middleware/Dependency for Limit Checks">
      <item>Create FastAPI dependency `check_tier_limits` in `backend/app/core/deps.py` or `backend/app/middleware/limits.py`</item>
      <item>Dependency checks limits BEFORE processing `POST /api/v1/upload` requests</item>
      <item>Dependency is injected into upload endpoint via `Depends(check_tier_limits)`</item>
      <item>Dependency receives authenticated user from `get_current_user` dependency chain</item>
      <item>Dependency is reusable for other endpoints that need limit checks</item>
    </criterion>
    <criterion id="2" title="File Size Limit Enforcement (FR42)">
      <item>Check file size from request before processing upload</item>
      <item>FREE tier: Maximum file size = 50MB (50 * 1024 * 1024 bytes)</item>
      <item>PRO tier: No file size limit (unlimited)</item>
      <item>PREMIUM tier: No file size limit (unlimited)</item>
      <item>If file exceeds limit, return 403 Forbidden with FILE_SIZE_LIMIT_EXCEEDED code</item>
    </criterion>
    <criterion id="3" title="Monthly Conversion Limit Enforcement (FR41)">
      <item>Query `UsageTracker.get_usage(user_id)` from Story 6.1 to get current usage</item>
      <item>FREE tier: Maximum conversions = 5 per month</item>
      <item>PRO tier: Unlimited conversions (bypass check)</item>
      <item>PREMIUM tier: Unlimited conversions (bypass check)</item>
      <item>If conversions exceed limit, return 403 Forbidden with CONVERSION_LIMIT_EXCEEDED code</item>
    </criterion>
    <criterion id="4" title="Pro/Premium Tier Bypass (FR43, FR44)">
      <item>Users with tier = PRO or PREMIUM bypass ALL limit checks</item>
      <item>No file size limit applied for PRO/PREMIUM</item>
      <item>No conversion count limit applied for PRO/PREMIUM</item>
      <item>Tier is fetched from user metadata (from Supabase Auth `user_metadata.tier`)</item>
      <item>Default to FREE tier if tier metadata is missing or unrecognized</item>
    </criterion>
    <criterion id="5" title="Error Response Schema">
      <item>Create Pydantic schema `LimitExceededError` in `backend/app/schemas/errors.py`</item>
      <item>Include fields: detail, code, tier, upgrade_url</item>
      <item>Code values: FILE_SIZE_LIMIT_EXCEEDED, CONVERSION_LIMIT_EXCEEDED</item>
      <item>403 status code returned (not 429) as per epics.md specification</item>
      <item>Response properly documented in OpenAPI (FastAPI autodocs)</item>
    </criterion>
    <criterion id="6" title="Configuration for Tier Limits">
      <item>Create tier limits configuration in `backend/app/core/config.py` or separate `limits.py`</item>
      <item>Configuration is easily modifiable for future tier adjustments</item>
      <item>Limits are centralized (not hardcoded in multiple places)</item>
    </criterion>
    <criterion id="7" title="Integration with Upload Endpoint">
      <item>Modify `POST /api/v1/upload` endpoint in `backend/app/api/v1/upload.py`</item>
      <item>Add `check_tier_limits` dependency to endpoint signature</item>
      <item>Limit check happens BEFORE file is processed or saved to Supabase Storage</item>
      <item>If limits pass, continue to existing upload logic</item>
      <item>Ensure proper ordering: authentication → limit check → file validation → upload</item>
    </criterion>
    <criterion id="8" title="Testing and Validation">
      <item>Unit tests for limit enforcement logic (file size rejection, conversion limit rejection, tier bypass, missing tier defaults)</item>
      <item>Integration tests for API endpoint (403 for limit exceeded, 202 for bypass)</item>
      <item>Verify error codes match expected values</item>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/prd.md</path>
        <title>Product Requirements Document</title>
        <section>Usage Limits &amp; Tier Management (FR41-FR47)</section>
        <snippet>FR41: Free tier users can convert up to 5 PDFs per month. FR42: Free tier users can upload files up to 50MB. FR43: Pro/Premium tier users have unlimited conversions. FR44: Pro/Premium tier users have no file size limits. FR47: System prevents conversions that exceed tier limits and prompts upgrade.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>Security Architecture</section>
        <snippet>Backend validates Supabase JWT tokens on protected endpoints. Rate limiting middleware to prevent abuse. File size limits enforced (configurable, default 50MB). Users segregated using Row Level Security policies.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Epic 6: Usage Tiers &amp; Limits Enforcement - Story 6.2</section>
        <snippet>Create middleware/dependency to check limits before POST /upload. Check 1: File size limit (50MB for Free, FR42). Check 2: Monthly conversion limit (5 for Free, FR41). Return 403 Forbidden with LIMIT_EXCEEDED code if blocked. Pro/Premium users bypass (FR43, FR44).</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/6-1-usage-tracking-supabase-postgresql.md</path>
        <title>Story 6.1 - Usage Tracking</title>
        <section>Dev Notes - Learnings</section>
        <snippet>UsageTracker service at `backend/app/services/usage_tracker.py`. Use `UsageTracker.get_usage(user_id)` to get current usage. Returns {month, conversion_count, tier, tier_limit, remaining}. CRITICAL: Always filter by user_id explicitly for defense-in-depth security.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/6-1-usage-tracking-supabase-postgresql.md</path>
        <title>Story 6.1 - Usage Tracking</title>
        <section>Implementation Notes</section>
        <snippet>Tier limits defined as tier_limits = {'FREE': 5, 'PRO': None, 'PREMIUM': None}. Redis caching for usage lookups with 1-hour TTL. HTTPException pattern for 403 errors with structured error body.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>backend/app/services/usage_tracker.py</path>
        <kind>service</kind>
        <symbol>UsageTracker</symbol>
        <lines>1-219</lines>
        <reason>REUSE - Contains get_usage(user_id) method that returns current conversion count, tier limit, and remaining conversions. Use this to check conversion limits.</reason>
      </artifact>
      <artifact>
        <path>backend/app/services/usage_tracker.py</path>
        <kind>method</kind>
        <symbol>UsageTracker.get_usage</symbol>
        <lines>119-218</lines>
        <reason>Key method returning {month, conversion_count, tier, tier_limit, remaining}. Call this to check if user has exceeded conversion limit.</reason>
      </artifact>
      <artifact>
        <path>backend/app/api/v1/upload.py</path>
        <kind>endpoint</kind>
        <symbol>upload_pdf</symbol>
        <lines>50-211</lines>
        <reason>MODIFY - Target endpoint to add check_tier_limits dependency. Currently validates file after reading - need to check limits BEFORE processing.</reason>
      </artifact>
      <artifact>
        <path>backend/app/core/auth.py</path>
        <kind>dependency</kind>
        <symbol>get_current_user</symbol>
        <lines>18-83</lines>
        <reason>REUSE - Authentication dependency that extracts AuthenticatedUser from JWT. Returns user with user_id, email, tier. Chain with check_tier_limits.</reason>
      </artifact>
      <artifact>
        <path>backend/app/schemas/auth.py</path>
        <kind>schema</kind>
        <symbol>AuthenticatedUser, SubscriptionTier</symbol>
        <lines>10-28</lines>
        <reason>REUSE - AuthenticatedUser has tier field (SubscriptionTier enum). Use tier.value to check FREE/PRO/PREMIUM.</reason>
      </artifact>
      <artifact>
        <path>backend/app/schemas/usage.py</path>
        <kind>schema</kind>
        <symbol>UsageResponse</symbol>
        <lines>10-37</lines>
        <reason>PATTERN - Follow this Pydantic schema pattern for LimitExceededError schema. Uses BaseModel with Field descriptors and json_schema_extra.</reason>
      </artifact>
      <artifact>
        <path>backend/app/services/validation/file_validator.py</path>
        <kind>service</kind>
        <symbol>FileValidationService</symbol>
        <lines>26-142</lines>
        <reason>REFERENCE - Already validates file type and size. Note: FREE_TIER_LIMIT = 50MB defined here. Consider centralizing limits in core/limits.py.</reason>
      </artifact>
      <artifact>
        <path>backend/app/core/supabase.py</path>
        <kind>client</kind>
        <symbol>get_supabase_client</symbol>
        <lines></lines>
        <reason>REUSE - Get Supabase client for UsageTracker initialization. Already used in upload.py.</reason>
      </artifact>
      <artifact>
        <path>backend/app/core/redis_client.py</path>
        <kind>client</kind>
        <symbol>get_cached_redis_client</symbol>
        <lines></lines>
        <reason>REUSE - Get Redis client for UsageTracker. Returns None if Redis unavailable (graceful degradation).</reason>
      </artifact>
      <artifact>
        <path>backend/app/core/config.py</path>
        <kind>config</kind>
        <symbol>Settings</symbol>
        <lines>12-71</lines>
        <reason>PATTERN - Add tier limit settings here if making configurable, or create separate limits.py module following same pydantic-settings pattern.</reason>
      </artifact>
    </code>
    <dependencies>
      <python>
        <package name="fastapi" version="0.122.0">Web framework - Depends, HTTPException</package>
        <package name="pydantic" version=">=2.11.7">Schema validation - BaseModel, Field</package>
        <package name="supabase" version="2.24.0">Database client - used by UsageTracker</package>
        <package name="redis" version="5.0.1">Cache client - used by UsageTracker</package>
        <package name="python-jose" version="3.3.0">JWT handling - used by auth middleware</package>
      </python>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="security">DEFENSE-IN-DEPTH: Always filter queries by user_id explicitly. Never rely solely on RLS policies. (Lesson from Story 6.1)</constraint>
    <constraint type="security">TIER VALIDATION: Default to FREE tier if tier is missing or unrecognized. Never trust client-provided tier data.</constraint>
    <constraint type="pattern">SERVICE PATTERN: Business logic MUST exist in services/ directory, NOT in API routes. Routes handle request/response only.</constraint>
    <constraint type="pattern">ERROR HANDLING: Use HTTPException with structured detail dict containing code, detail, and context fields.</constraint>
    <constraint type="pattern">DEPENDENCY INJECTION: Use FastAPI Depends() for injecting services and auth. Chain dependencies for proper ordering.</constraint>
    <constraint type="http">STATUS CODES: Use 403 Forbidden for limit exceeded (not 429 Rate Limited) per epics.md specification.</constraint>
    <constraint type="http">ERROR CODES: Use uppercase snake_case: FILE_SIZE_LIMIT_EXCEEDED, CONVERSION_LIMIT_EXCEEDED</constraint>
    <constraint type="testing">MOCK PATTERNS: Use standard pytest fixtures and mocks. Follow patterns in tests/conftest.py.</constraint>
    <constraint type="ordering">DEPENDENCY ORDER: Authentication → Limit Check → File Validation → Upload. Limits checked BEFORE file processing.</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>POST /api/v1/upload</name>
      <kind>REST endpoint</kind>
      <signature>POST /api/v1/upload (multipart/form-data: file) → 202 Accepted | 403 Forbidden</signature>
      <path>backend/app/api/v1/upload.py</path>
    </interface>
    <interface>
      <name>UsageTracker.get_usage</name>
      <kind>service method</kind>
      <signature>get_usage(user_id: str) → dict {month, conversion_count, tier, tier_limit, remaining}</signature>
      <path>backend/app/services/usage_tracker.py</path>
    </interface>
    <interface>
      <name>check_tier_limits (NEW)</name>
      <kind>FastAPI dependency</kind>
      <signature>check_tier_limits(request: Request, current_user: AuthenticatedUser = Depends(get_current_user)) → None | HTTPException(403)</signature>
      <path>backend/app/middleware/limits.py (to create)</path>
    </interface>
    <interface>
      <name>LimitExceededError (NEW)</name>
      <kind>Pydantic schema</kind>
      <signature>LimitExceededError(detail: str, code: str, tier: str, upgrade_url: str, current_count?: int, limit?: int, current_size_mb?: float, max_size_mb?: int, reset_date?: str)</signature>
      <path>backend/app/schemas/errors.py (to create)</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      <paragraph>Backend testing uses pytest 8.x with FastAPI TestClient for API tests. Test files follow test_*.py naming. Unit tests use mocked dependencies (mock_supabase, mock_redis). Integration tests use real database with test fixtures. Coverage target: 80% minimum. Use fixtures from tests/conftest.py for common setup.</paragraph>
    </standards>
    <locations>
      <location>backend/tests/unit/</location>
      <location>backend/tests/unit/middleware/ (NEW - to create)</location>
      <location>backend/tests/integration/</location>
    </locations>
    <ideas>
      <idea acId="2">Test FREE tier file size rejection when file &gt; 50MB</idea>
      <idea acId="2">Test FREE tier file size acceptance when file ≤ 50MB</idea>
      <idea acId="2">Test PRO/PREMIUM tier bypasses file size limit (100MB+ allowed)</idea>
      <idea acId="3">Test FREE tier conversion limit rejection when count ≥ 5</idea>
      <idea acId="3">Test FREE tier conversion allowed when count &lt; 5</idea>
      <idea acId="3">Test PRO/PREMIUM tier bypasses conversion limit</idea>
      <idea acId="4">Test missing tier defaults to FREE limits</idea>
      <idea acId="4">Test unrecognized tier value defaults to FREE limits</idea>
      <idea acId="5">Test 403 response includes correct error code (FILE_SIZE_LIMIT_EXCEEDED or CONVERSION_LIMIT_EXCEEDED)</idea>
      <idea acId="5">Test 403 response includes upgrade_url field</idea>
      <idea acId="7">Test limit check runs BEFORE file is processed (Content-Length header check)</idea>
      <idea acId="8">Integration test: Authenticated FREE user at limit → 403 response</idea>
      <idea acId="8">Integration test: Authenticated PRO user at limit → 202 bypass</idea>
    </ideas>
  </tests>
</story-context>
